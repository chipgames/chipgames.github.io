/**
 * ÌÉÄÏõå Í¥ÄÎ†® Î™®Îì† Î°úÏßÅÏùÑ Îã¥ÎãπÌïòÎäî ÌååÏùº
 * ÌÉÄÏõåÏùò ÏÉùÏÑ±, ÏóÖÍ∑∏Î†àÏù¥Îìú, Í≥µÍ≤©, ÌäπÏàò Îä•Î†• Îì± Í≤åÏûÑ ÎÇ¥ ÌÉÄÏõåÏùò ÎèôÏûëÏùÑ Í¥ÄÎ¶¨
 */

// ÌÉÄÏõå Í¥ÄÎ†® ÏÉÅÏàò
const TOWER_TYPES = {
    BASIC: {
        name: t('basicTower'),
        cost: 30,
        damage: 5,
        range: 2,
        cooldown: 100,
        color: 'blue',
        special: {
            name: t('towerSpecialEnhancedShot'),
            description: t('towerSpecialEnhancedShotDesc'),
            cooldown: 30,
            duration: 10,
            effect: (tower) => {
                tower.damage *= 1.5;
                setTimeout(() => {
                    tower.damage /= 1.5;
                }, 10000);
            }
        }
    },
    ICE: {
        name: t('iceTower'),
        cost: 100,
        damage: 5,
        range: 2,
        cooldown: 90,
        color: 'lightblue',
        freezeDuration: 2,
        special: {
            name: t('towerSpecialFrostExplosion'),
            description: t('towerSpecialFrostExplosionDesc'),
            cooldown: 45,
            effect: (tower) => {
                enemies.forEach(enemy => {
                    const dx = (enemy.x - tower.x) * TILE_SIZE;
                    const dy = (enemy.y - tower.y) * TILE_SIZE;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= tower.range * TILE_SIZE) {
                        enemy.applyStatusEffect('FROZEN', 5);
                        showSkillEffect(enemy.x, enemy.y, '‚ùÑÔ∏è');
                    }
                });
                playSound('ice_special');
            }
        }
    },
    POISON: {
        name: t('poisonTower'),
        cost: 200,
        damage: 3,
        range: 2,
        cooldown: 60,
        color: 'green',
        poisonDamage: 2,
        poisonDuration: 5,
        special: {
            name: t('towerSpecialPoisonCloud'),
            description: t('towerSpecialPoisonCloudDesc'),
            cooldown: 40,
            effect: (tower) => {
                enemies.forEach(enemy => {
                    const dx = (enemy.x - tower.x) * TILE_SIZE;
                    const dy = (enemy.y - tower.y) * TILE_SIZE;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= tower.range * TILE_SIZE) {
                        enemy.poisonDamage = tower.poisonDamage * 3;
                        enemy.poisonDuration = tower.poisonDuration * 2;
                    }
                });
            }
        }
    },
    LASER: {
        name: t('laserTower'),
        cost: 300,
        damage: 8,
        range: 2.5,
        cooldown: 120,
        color: 'red',
        continuousDamage: 5,
        special: {
            name: t('towerSpecialOverheatLaser'),
            description: t('towerSpecialOverheatLaserDesc'),
            cooldown: 60,
            duration: 10,
            effect: (tower) => {
                tower.continuousDamage *= 3;
                setTimeout(() => {
                    tower.continuousDamage /= 3;
                }, 10000);
            }
        }
    },
    SPLASH: {
        name: t('splashTower'),
        cost: 400,
        damage: 7,
        range: 2,
        cooldown: 110,
        color: 'purple',
        splashRadius: 1.5,
        slowEffect: 0.3,
        special: {
            name: t('towerSpecialMassiveExplosion'),
            description: t('towerSpecialMassiveExplosionDesc'),
            cooldown: 50,
            duration: 8,
            effect: (tower) => {
                tower.splashRadius *= 2;
                tower.damage *= 1.5;
                setTimeout(() => {
                    tower.splashRadius /= 2;
                    tower.damage /= 1.5;
                }, 8000);
            }
        }
    },
    SUPPORT: {
        name: t('supportTower'),
        cost: 500,
        damage: 0,
        range: 3,
        cooldown: 0,
        color: 'yellow',
        buffRange: 3,
        buffMultiplier: 1.2,
        special: {
            name: t('towerSpecialFullEnhancement'),
            description: t('towerSpecialFullEnhancementDesc'),
            cooldown: 60,
            duration: 15,
            effect: (tower) => {
                towers.forEach(t => {
                    if (t !== tower) {
                        t.damage *= 1.3;
                    }
                });
                setTimeout(() => {
                    towers.forEach(t => {
                        if (t !== tower) {
                            t.damage /= 1.3;
                        }
                    });
                }, 15000);
            }
        }
    }
};

// Tower ÌÅ¥ÎûòÏä§
// Í∞Å ÌÉÄÏõå Í∞ùÏ≤¥Îäî Tower ÌÅ¥ÎûòÏä§Î•º ÌÜµÌï¥ ÏÉùÏÑ±ÎêòÎ©∞, ÏúÑÏπò, Í≥µÍ≤©Î†•, Î≤îÏúÑ Îì± Îã§ÏñëÌïú ÏÜçÏÑ±ÏùÑ Í∞ÄÏßê
class Tower {
    // ÏÉùÏÑ±Ïûê: ÌÉÄÏõåÏùò Ï¥àÍ∏∞ ÏÜçÏÑ±ÏùÑ ÏÑ§Ï†ï
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.level = 1;
        this.experience = 0;
        this.experienceToNextLevel = 100;

        // ÌäπÏàò Îä•Î†• Í¥ÄÎ†® ÏÜçÏÑ± Í∞úÏÑ†
        this.specialCooldown = 0;
        this.specialActive = false;
        this.specialDuration = 0;
        this.special = TOWER_TYPES[type].special;

        // ÏóÖÍ∑∏Î†àÏù¥Îìú Î†àÎ≤® Ï¥àÍ∏∞Ìôî (ÏµúÎåÄ Î†àÎ≤® Ï†úÌïú Ï∂îÍ∞Ä)
        this.rangeLevel = 0;
        this.damageLevel = 0;
        this.speedLevel = 0;
        this.bulletLevel = 0;
        this.maxUpgradeLevel = 5; // ÏµúÎåÄ ÏóÖÍ∑∏Î†àÏù¥Îìú Î†àÎ≤® Ï†úÌïú

        const towerType = TOWER_TYPES[type];
        this.baseDamage = towerType.damage;
        this.baseRange = towerType.range;
        this.baseCooldown = towerType.cooldown;
        this.damage = this.baseDamage;
        this.range = this.baseRange;
        this.maxCooldown = this.baseCooldown;
        this.cooldown = 0;
        this.color = towerType.color;
        this.bulletCount = 1;

        // ÌäπÏàò Îä•Î†• Ï¥àÍ∏∞Ìôî Í∞úÏÑ†
        this.initializeSpecialEffects(type, towerType);

        // Î≤ÑÌîÑ Ìö®Í≥º Ï∂îÏ†ÅÏùÑ ÏúÑÌïú Set
        this.activeBuffs = new Set();
        this.activeCombos = new Set();
        this.shieldEffectTime = 0;
    }

    // ÌäπÏàò Ìö®Í≥º Ï¥àÍ∏∞Ìôî
    // ÌÉÄÏõå ÌÉÄÏûÖÏóê Îî∞Î•∏ ÌäπÏàò Ìö®Í≥º ÏÜçÏÑ±ÏùÑ Ï¥àÍ∏∞Ìôî
    initializeSpecialEffects(type, towerType) {
        switch (type) {
            case 'SPLASH':
                this.splashRadius = towerType.splashRadius;
                this.slowEffect = towerType.slowEffect;
                break;
            case 'POISON':
                this.poisonDamage = towerType.poisonDamage;
                this.poisonDuration = towerType.poisonDuration;
                break;
            case 'ICE':
                this.freezeDuration = towerType.freezeDuration;
                break;
            case 'LASER':
                this.continuousDamage = towerType.continuousDamage;
                break;
            case 'SUPPORT':
                this.buffRange = towerType.buffRange;
                this.buffMultiplier = towerType.buffMultiplier;
                this.buffedTowers = new Set();
                break;
        }
    }

    // ÌäπÏàò Îä•Î†• ÏÇ¨Ïö©
    // ÌÉÄÏõåÏùò ÌäπÏàò Îä•Î†•ÏùÑ Î∞úÎèôÌïòÍ≥† Ïø®Îã§Ïö¥ÏùÑ Ï†ÅÏö©
    useSpecial() {
        if (this.specialCooldown > 0 || this.specialActive) return false;

        if (this.special && this.special.effect) {
            this.special.effect(this);
            this.specialCooldown = this.special.cooldown;
            this.specialActive = true;
            this.specialDuration = this.special.duration || 0;

            // ÌäπÏàò Îä•Î†• ÏÇ¨Ïö© Ïù¥ÌéôÌä∏
            showSkillEffect(this.x, this.y, this.getSpecialIcon());
            playSound(`${this.type.toLowerCase()}_special`);
            return true;
        }
        return false;
    }

    // ÌäπÏàò Îä•Î†• ÏïÑÏù¥ÏΩò Î∞òÌôò
    // ÌÉÄÏõå ÌÉÄÏûÖÏóê Îî∞Î•∏ ÌäπÏàò Îä•Î†• ÏïÑÏù¥ÏΩòÏùÑ Î∞òÌôò
    getSpecialIcon() {
        switch (this.type) {
            case 'ICE': return '‚ùÑÔ∏è';
            case 'POISON': return '‚ò†Ô∏è';
            case 'LASER': return '‚ö°';
            case 'SPLASH': return 'üí•';
            case 'SUPPORT': return '‚ú®';
            default: return '‚≠ê';
        }
    }

    // ÏóÖÍ∑∏Î†àÏù¥Îìú
    // ÌÉÄÏõåÏùò ÌäπÏ†ï ÏÜçÏÑ±ÏùÑ ÏóÖÍ∑∏Î†àÏù¥ÎìúÌïòÍ≥† ÎπÑÏö©ÏùÑ Ï∞®Í∞ê
    upgrade(upgradeType) {
        if (this[`${upgradeType}Level`] >= this.maxUpgradeLevel) {
            return false;
        }

        const upgradeCost = this.getUpgradeCost(upgradeType);
        if (gameState.gold < upgradeCost) {
            return false;
        }

        gameState.gold -= upgradeCost;
        this[`${upgradeType}Level`]++;

        switch (upgradeType) {
            case 'damage':
                this.damage = Math.floor(this.baseDamage * (1 + this.damageLevel * 0.2));
                break;
            case 'range':
                this.range = this.baseRange + (this.rangeLevel * 0.5);
                break;
            case 'speed':
                this.maxCooldown = Math.max(10, this.baseCooldown * Math.pow(0.9, this.speedLevel));
                break;
            case 'bullet':
                this.bulletCount = 1 + this.bulletLevel;
                break;
        }

        // ÏóÖÍ∑∏Î†àÏù¥Îìú Ïù¥ÌéôÌä∏
        showUpgradeEffect(this.x, this.y);
        playSound('upgrade');
        return true;
    }

    // ÏóÖÍ∑∏Î†àÏù¥Îìú ÎπÑÏö© Í≥ÑÏÇ∞
    // ÏóÖÍ∑∏Î†àÏù¥Îìú ÌÉÄÏûÖÏóê Îî∞Î•∏ ÎπÑÏö©ÏùÑ Í≥ÑÏÇ∞
    getUpgradeCost(upgradeType) {
        const baseCost = 100;
        let level = this[`${upgradeType}Level`];
        if (typeof level !== 'number' || isNaN(level)) level = 1;
        return Math.floor(baseCost * Math.pow(1.5, level));
    }

    // Í≥µÍ≤© Ïã§Ìñâ
    // Î≤îÏúÑ ÎÇ¥ Ï†ÅÏùÑ Ï∞æÏïÑ Í≥µÍ≤©ÏùÑ Ïã§Ìñâ
    attack(enemies) {
        if (this.cooldown > 0) {
            this.cooldown--;
            return;
        }

        // Î≤îÏúÑ ÎÇ¥ Ï†Å Ï∞æÍ∏∞ (Í∞ÄÏû• Í∞ÄÍπåÏö¥ Ï†Å Ïö∞ÏÑ†)
        const target = this.findTarget(enemies);
        if (!target) return;

        // Í≥µÍ≤© Ïã§Ìñâ
        this.executeAttack(target);
        this.cooldown = this.maxCooldown;
    }

    // ÌÉÄÍ≤ü Ï∞æÍ∏∞
    // Í≥µÍ≤© Î≤îÏúÑ ÎÇ¥ Í∞ÄÏû• Ï†ÅÏ†àÌïú ÌÉÄÍ≤üÏùÑ Ï∞æÏùå
    findTarget(enemies) {
        if (!enemies || !Array.isArray(enemies)) return null;
        return enemies.filter(enemy => enemy && enemy.x !== undefined && enemy.y !== undefined)  // enemyÍ∞Ä Ïú†Ìö®ÌïúÏßÄ ÌôïÏù∏
            .filter(enemy => {
                const dx = enemy.x - this.x;
                const dy = enemy.y - this.y;
                return Math.sqrt(dx * dx + dy * dy) <= this.range;
            })[0];
    }

    // Í≥µÍ≤© Ïã§Ìñâ
    // ÏÑ†ÌÉùÎêú ÌÉÄÍ≤üÏóê ÎåÄÌï¥ Í≥µÍ≤©ÏùÑ Ïã§Ìñâ
    executeAttack(target) {
        const isCritical = Math.random() < CRITICAL_CHANCE;
        const damage = isCritical ? this.damage * CRITICAL_MULTIPLIER : this.damage;

        // Í≥µÍ≤© Ïù¥ÌéôÌä∏ÏôÄ ÏÇ¨Ïö¥Îìú Ïû¨ÏÉù
        showAttackEffect(this.x, this.y, target.x, target.y, isCritical);

        switch (this.type) {
            case 'BASIC': {
                const actualDamage = target.takeDamage(damage, isCritical, this);
                if (actualDamage > 0) showDamageNumber(target.x, target.y, actualDamage, isCritical);
                break;
            }
            case 'ICE': {
                const actualDamage = target.takeDamage(damage, isCritical, this);
                if (actualDamage > 0) showDamageNumber(target.x, target.y, actualDamage, isCritical);
                target.applyStatusEffect('FROZEN', this.freezeDuration);
                break;
            }
            case 'POISON': {
                const actualDamage = target.takeDamage(damage, isCritical, this);
                if (actualDamage > 0) showDamageNumber(target.x, target.y, actualDamage, isCritical);
                target.poisonDamage = this.poisonDamage;
                target.poisonDuration = this.poisonDuration;
                break;
            }
            case 'LASER': {
                const actualDamage = target.takeDamage(damage, isCritical, this);
                if (actualDamage > 0) showDamageNumber(target.x, target.y, actualDamage, isCritical);
                target.continuousDamage = this.continuousDamage;
                break;
            }
            case 'SPLASH': {
                const actualDamage = this.executeSplashAttack(target, damage);
                if (actualDamage > 0) showDamageNumber(target.x, target.y, actualDamage, isCritical);
                break;
            }
            case 'SUPPORT':
                this.executeSupportBuff();
                // showDamageNumber Ìò∏Ï∂úÌïòÏßÄ ÏïäÏùå
                break;
        }
    }

    // Ïä§ÌîåÎûòÏãú Í≥µÍ≤© Ïã§Ìñâ
    // Ï£ºÎ≥Ä Ï†ÅÎì§ÏóêÍ≤å Î≤îÏúÑ Îç∞ÎØ∏ÏßÄÎ•º Ï†ÅÏö©
    executeSplashAttack(mainTarget, damage) {
        const actualDamage = mainTarget.takeDamage(damage, false, this);
        mainTarget.applyStatusEffect('SLOWED', this.slowEffect);

        // Î≤îÏúÑ ÎÇ¥ Îã§Î•∏ Ï†ÅÎì§ÎèÑ Îç∞ÎØ∏ÏßÄ
        enemies.forEach(enemy => {
            if (enemy === mainTarget) return;
            const dx = (enemy.x - mainTarget.x) * TILE_SIZE;
            const dy = (enemy.y - mainTarget.y) * TILE_SIZE;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance <= this.splashRadius * TILE_SIZE) {
                enemy.takeDamage(damage * 0.5, false, this);
                enemy.applyStatusEffect('SLOWED', this.slowEffect);
            }
        });
        return actualDamage;
    }

    // ÏßÄÏõê Î≤ÑÌîÑ Ïã§Ìñâ
    // Ï£ºÎ≥Ä ÌÉÄÏõåÎì§ÏóêÍ≤å Î≤ÑÌîÑ Ìö®Í≥ºÎ•º Ï†ÅÏö©
    executeSupportBuff() {
        towers.forEach(tower => {
            if (tower === this) return;
            const dx = tower.x - this.x;
            const dy = tower.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            // ÏßÄÏõê Î≤îÏúÑ ÎÇ¥Ïóê ÏûàÏúºÎ©¥ Î≤ÑÌîÑ Ï†ÅÏö©
            if (distance <= this.buffRange) {
                if (!this.buffedTowers.has(tower)) {
                    // Ìï≠ÏÉÅ baseDamage Í∏∞Ï§ÄÏúºÎ°úÎßå Î≤ÑÌîÑ Ï†ÅÏö©
                    tower.damage = tower.baseDamage * this.buffMultiplier;
                    this.buffedTowers.add(tower);
                }
            } else if (this.buffedTowers.has(tower)) {
                // ÏßÄÏõê Î≤îÏúÑÏóêÏÑú Î≤óÏñ¥ÎÇòÎ©¥ baseDamageÎ°ú Î≥µÍµ¨
                tower.damage = tower.baseDamage;
                this.buffedTowers.delete(tower);
            }
        });
    }

    // Î≤ÑÌîÑ Ï†úÍ±∞
    // Ï†ÅÏö©Îêú Î™®Îì† Î≤ÑÌîÑ Ìö®Í≥ºÎ•º Ï†úÍ±∞
    removeBuffs() {
        this.buffedTowers.forEach(tower => {
            tower.damage /= this.buffMultiplier;
        });
        this.buffedTowers.clear();
    }

    // Í≤ΩÌóòÏπò ÌöçÎìù
    // ÌÉÄÏõåÍ∞Ä Í≤ΩÌóòÏπòÎ•º ÌöçÎìùÌïòÍ≥† Î†àÎ≤®ÏóÖ Ï≤òÎ¶¨
    gainExperience(amount) {
        this.experience += amount;

        // ÌÉÄÏõå Î†àÎ≤®ÏóÖ Ï≤¥ÌÅ¨
        while (this.experience >= this.experienceToNextLevel) {
            this.experience -= this.experienceToNextLevel;
            this.level++;
            this.experienceToNextLevel = Math.floor(this.experienceToNextLevel * 1.5);

            // Î†àÎ≤®ÏóÖ Ïãú Îä•Î†•Ïπò ÏÉÅÏäπ
            this.damage = Math.floor(this.damage * 1.5);
            this.baseDamage = Math.floor(this.baseDamage * 1.5); // baseDamageÎèÑ Ìï®Íªò Ï¶ùÍ∞Ä
            this.range += 0.5;
            this.baseRange += 0.5; // baseRangeÎèÑ Ìï®Íªò Ï¶ùÍ∞Ä
            if (this.splashRadius) this.splashRadius += 0.5;
            this.maxCooldown = Math.max(10, this.maxCooldown * 0.8);
            this.baseCooldown = Math.max(10, this.baseCooldown * 0.8); // baseCooldownÎèÑ Ìï®Íªò Í∞êÏÜå

            // ÌäπÏàò Îä•Î†• Í∞ïÌôî
            if (this.type === 'LASER') {
                this.continuousDamage = Math.floor(this.damage * 0.2);
            }

            // Î†àÎ≤®ÏóÖ Ïù¥ÌéôÌä∏
            showLevelUpEffect(this);
            playSound('powerup');
        }
    }

    // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    // ÌÉÄÏõåÏùò ÏÉÅÌÉúÎ•º Ìïú ÌîÑÎ†àÏûÑÎßàÎã§ Í∞±Ïã†
    update() {
        if (this.specialCooldown > 0) {
            this.specialCooldown--;
        }
    }

    // ÌÉÄÏõå Í∑∏Î¶¨Í∏∞
    // ÌÉÄÏõåÎ•º Ï∫îÎ≤ÑÏä§Ïóê Í∑∏Î¶º
    draw() {
        const centerX = this.x * TILE_SIZE + TILE_SIZE / 2;
        const centerY = this.y * TILE_SIZE + TILE_SIZE / 2;
        const radius = TILE_SIZE / 2 - 4;

        // ÏÇ¨Í±∞Î¶¨ Ïõê ÎÇ¥Î∂Ä Ï±ÑÏö∞Í∏∞ (Îçî ÏßÑÌïòÍ≤å)
        ctx.save();
        ctx.globalAlpha = 0.18;
        ctx.beginPath();
        ctx.arc(
            this.x * TILE_SIZE + TILE_SIZE / 2,
            this.y * TILE_SIZE + TILE_SIZE / 2,
            this.range * TILE_SIZE,
            0,
            Math.PI * 2
        );
        ctx.fillStyle = this.color === 'blue' ? 'rgba(0, 0, 255, 0.18)' :
            this.color === 'red' ? 'rgba(255, 0, 0, 0.18)' :
                this.color === 'green' ? 'rgba(0, 255, 0, 0.18)' :
                    this.color === 'yellow' ? 'rgba(255, 255, 0, 0.18)' :
                        this.color === 'purple' ? 'rgba(128, 0, 128, 0.18)' :
                            'rgba(255, 255, 255, 0.18)';
        ctx.fill();
        ctx.restore();

        // ÏÇ¨Í±∞Î¶¨ Ïõê ÌÖåÎëêÎ¶¨ Í∞ïÏ°∞
        ctx.save();
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.arc(
            this.x * TILE_SIZE + TILE_SIZE / 2,
            this.y * TILE_SIZE + TILE_SIZE / 2,
            this.range * TILE_SIZE,
            0,
            Math.PI * 2
        );
        ctx.stroke();
        ctx.restore();

        // ÌÉÄÏõå Î≤îÏúÑ ÌëúÏãú (Ìï≠ÏÉÅ ÌëúÏãú)
        const gradient = ctx.createRadialGradient(
            this.x * TILE_SIZE + TILE_SIZE / 2,
            this.y * TILE_SIZE + TILE_SIZE / 2,
            0,
            this.x * TILE_SIZE + TILE_SIZE / 2,
            this.y * TILE_SIZE + TILE_SIZE / 2,
            this.range * TILE_SIZE
        );

        // ÏÉâÏÉÅ Í∞íÏùÑ rgba ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
        const color = this.color;
        const rgbaColor = color === 'blue' ? 'rgba(0, 0, 255, 0.25)' :
            color === 'red' ? 'rgba(255, 0, 0, 0.25)' :
                color === 'green' ? 'rgba(0, 255, 0, 0.25)' :
                    color === 'yellow' ? 'rgba(255, 255, 0, 0.25)' :
                        color === 'purple' ? 'rgba(128, 0, 128, 0.25)' :
                            'rgba(255, 255, 255, 0.25)';

        // ÌÉÄÏõå Î≥∏Ï≤¥ Í∑∏Î¶¨Í∏∞
        ctx.save();

        // ÌÉÄÏõå ÌÉÄÏûÖÎ≥Ñ Î™®Ïñë Ï∞®Î≥ÑÌôî
        switch (this.type) {
            case 'BASIC':
                // Í∏∞Î≥∏ ÌÉÄÏõå: ÏõêÌòï
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();
                break;

            case 'ICE':
                // ÏñºÏùå ÌÉÄÏõå: Ïú°Í∞ÅÌòï
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI * 2) / 6;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                break;

            case 'POISON':
                // ÎèÖ ÌÉÄÏõå: Î≥Ñ Î™®Ïñë
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * Math.PI * 2) / 5 - Math.PI / 2;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                break;

            case 'LASER':
                // Î†àÏù¥Ï†Ä ÌÉÄÏõå: ÏÇºÍ∞ÅÌòï
                ctx.beginPath();
                for (let i = 0; i < 3; i++) {
                    const angle = (i * Math.PI * 2) / 3;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                break;

            case 'SPLASH':
                // Ïä§ÌîåÎûòÏãú ÌÉÄÏõå: ÏÇ¨Í∞ÅÌòï
                ctx.beginPath();
                ctx.rect(centerX - radius, centerY - radius, radius * 2, radius * 2);
                ctx.fill();
                break;

            case 'SUPPORT':
                // ÏßÄÏõê ÌÉÄÏõå: Ïã≠ÏûêÍ∞Ä
                ctx.beginPath();
                ctx.rect(centerX - radius / 2, centerY - radius, radius, radius * 2);
                ctx.rect(centerX - radius, centerY - radius / 2, radius * 2, radius);
                ctx.fill();
                break;
        }

        // ÌÉÄÏõå ÌÖåÎëêÎ¶¨
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();

        // ÌÉÄÏõå ÏïÑÏù¥ÏΩò
        ctx.font = '16px Arial';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(
            TOWER_ICONS[this.type],
            centerX,
            centerY - 5
        );

        // ÌÉÄÏõå Ïù¥Î¶Ñ ÌëúÏãú
        const towerName = TOWER_TYPES[this.type].name;
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // ÌÉÄÏõå Ïù¥Î¶Ñ ÌÅ¨Í∏∞ Ï∏°Ï†ï
        const nameWidth = ctx.measureText(towerName).width;
        const nameHeight = 16;
        const nameX = centerX;
        const nameY = centerY - 20;

        // ÌÉÄÏõå Ïù¥Î¶Ñ Î∞∞Í≤Ω
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(
            nameX - nameWidth / 2 - 4,
            nameY - nameHeight / 2 - 2,
            nameWidth + 8,
            nameHeight + 4
        );

        // ÌÉÄÏõå Ïù¥Î¶Ñ ÌÖåÎëêÎ¶¨
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.strokeRect(
            nameX - nameWidth / 2 - 4,
            nameY - nameHeight / 2 - 2,
            nameWidth + 8,
            nameHeight + 4
        );

        // ÌÉÄÏõå Ïù¥Î¶Ñ ÌÖçÏä§Ìä∏
        ctx.fillStyle = '#ffd700'; // Í≥®Îìú ÏÉâÏÉÅ
        ctx.fillText(t(towerName), nameX, nameY);

        // Î†àÎ≤® ÌëúÏãú (Î∞∞Í≤ΩÍ≥º ÌÖåÎëêÎ¶¨ Ï∂îÍ∞Ä)
        const levelText = `Lv.${this.level}`;
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Î†àÎ≤® ÌÖçÏä§Ìä∏ ÌÅ¨Í∏∞ Ï∏°Ï†ï
        const levelWidth = ctx.measureText(levelText).width;
        const levelHeight = 16;
        const levelX = centerX;
        const levelY = centerY + 10;

        // Î†àÎ≤® Î∞∞Í≤Ω
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(
            levelX - levelWidth / 2 - 4,
            levelY - levelHeight / 2 - 2,
            levelWidth + 8,
            levelHeight + 4
        );

        // Î†àÎ≤® ÌÖåÎëêÎ¶¨
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.strokeRect(
            levelX - levelWidth / 2 - 4,
            levelY - levelHeight / 2 - 2,
            levelWidth + 8,
            levelHeight + 4
        );

        // Î†àÎ≤® ÌÖçÏä§Ìä∏
        ctx.fillStyle = '#fff';
        ctx.fillText(levelText, levelX, levelY);

        // Í≥µÍ≤© Ïø®Îã§Ïö¥ ÌëúÏãú
        if (this.cooldown > 0) {
            const cooldownProgress = 1 - (this.cooldown / this.maxCooldown);
            const cooldownRadius = radius * 0.8;

            // Ïø®Îã§Ïö¥ Î∞∞Í≤Ω Ïõê
            ctx.beginPath();
            ctx.arc(centerX, centerY, cooldownRadius, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Ïø®Îã§Ïö¥ ÏßÑÌñâ ÌëúÏãú
            ctx.beginPath();
            ctx.arc(centerX, centerY, cooldownRadius, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * cooldownProgress));
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // ÌäπÏàò Îä•Î†• Ïø®Îã§Ïö¥ ÌëúÏãú
        if (this.specialCooldown > 0) {
            const specialCooldownProgress = 1 - (this.specialCooldown / this.specialMaxCooldown);
            const specialRadius = radius * 0.6;

            // ÌäπÏàò Îä•Î†• Ïø®Îã§Ïö¥ Î∞∞Í≤Ω Ïõê
            ctx.beginPath();
            ctx.arc(centerX, centerY, specialRadius, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)'; // Í≥®Îìú ÏÉâÏÉÅ
            ctx.lineWidth = 2;
            ctx.stroke();

            // ÌäπÏàò Îä•Î†• Ïø®Îã§Ïö¥ ÏßÑÌñâ ÌëúÏãú
            ctx.beginPath();
            ctx.arc(centerX, centerY, specialRadius, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * specialCooldownProgress));
            ctx.strokeStyle = '#ffd700'; // Í≥®Îìú ÏÉâÏÉÅ
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        ctx.restore();
    }

    // ÌåêÎß§ Í∞ÄÏπò Í≥ÑÏÇ∞
    // ÌÉÄÏõåÏùò ÌåêÎß§ Ïãú ÏñªÏùÑ Ïàò ÏûàÎäî Í≥®ÎìúÎ•º Í≥ÑÏÇ∞
    getSellValue() {
        const baseValue = TOWER_TYPES[this.type].cost || 100;
        // Ïã§Ï†ú Ìà¨ÏûêÌïú ÏóÖÍ∑∏Î†àÏù¥Îìú ÎπÑÏö© ÎàÑÏ†Å
        let upgradeCost = 0;
        const baseUpgradeCost = 100;
        for (let i = 0; i < this.rangeLevel; i++) {
            upgradeCost += Math.floor(baseUpgradeCost * Math.pow(1.5, i));
        }
        for (let i = 0; i < this.damageLevel; i++) {
            upgradeCost += Math.floor(baseUpgradeCost * Math.pow(1.5, i));
        }
        for (let i = 0; i < this.speedLevel; i++) {
            upgradeCost += Math.floor(baseUpgradeCost * Math.pow(1.5, i));
        }
        for (let i = 0; i < this.bulletLevel; i++) {
            upgradeCost += Math.floor(baseUpgradeCost * Math.pow(1.5, i));
        }
        // ÌäπÏàò ÏóÖÍ∑∏Î†àÏù¥Îìú(Î†àÎ≤® 3 Ïù¥ÏÉÅ)
        if (this.specialLevel) {
            for (let i = 0; i < this.specialLevel; i++) {
                upgradeCost += Math.floor(baseUpgradeCost * Math.pow(1.5, i));
            }
        }
        return Math.floor((baseValue + upgradeCost) * 0.7);
    }

    // ÌÉÄÏõå Î≤îÏúÑ ÎØ∏Î¶¨Î≥¥Í∏∞ ÌëúÏãú
    // ÌÉÄÏõå ÏÑ§Ïπò Ï†Ñ Î≤îÏúÑÎ•º ÎØ∏Î¶¨ Î≥¥Ïó¨Ï§å
    showTowerRangePreview(x, y, range, type) {
        if (rangePreview) {
            rangePreview.remove();
        }

        rangePreview = document.createElement('div');
        rangePreview.className = 'tower-range-preview';

        // ÌÉÄÏõå Ï§ëÏã¨ÏùÑ Í∏∞Ï§ÄÏúºÎ°ú Í≥ÑÏÇ∞
        const centerX = x * TILE_SIZE + TILE_SIZE / 2;
        const centerY = y * TILE_SIZE + TILE_SIZE / 2;
        const diameter = range * TILE_SIZE * 2;

        rangePreview.style.left = `${centerX - diameter / 2}px`;
        rangePreview.style.top = `${centerY - diameter / 2}px`;
        rangePreview.style.width = `${diameter}px`;
        rangePreview.style.height = `${diameter}px`;

        // ÌÉÄÏõå Ï¢ÖÎ•òÏóê Îî∞Î•∏ ÏÉâÏÉÅ ÏÑ§Ï†ï
        const tower = TOWER_TYPES[type];
        rangePreview.style.backgroundColor = `${tower.color}20`;
        rangePreview.style.borderColor = tower.color;

        document.querySelector('.game-area').appendChild(rangePreview);
    }

    // ÌÉÄÏõå Î≤îÏúÑ ÎØ∏Î¶¨Î≥¥Í∏∞ Ïà®Í∏∞Í∏∞
    // ÌÉÄÏõå Î≤îÏúÑ ÎØ∏Î¶¨Î≥¥Í∏∞Î•º Ï†úÍ±∞
    hideTowerRangePreview() {
        if (rangePreview) {
            rangePreview.remove();
            rangePreview = null;
        }
    }

    // ÏóÖÍ∑∏Î†àÏù¥Îìú Í∞ÄÎä• Ïó¨Î∂Ä ÌôïÏù∏
    // ÌäπÏ†ï ÏóÖÍ∑∏Î†àÏù¥ÎìúÍ∞Ä Í∞ÄÎä•ÌïúÏßÄ ÌôïÏù∏
    canUpgrade(upgradeType) {
        if (upgradeType === 'special') {
            // ÌäπÏàò ÏóÖÍ∑∏Î†àÏù¥ÎìúÎäî Î†àÎ≤® 3 Ïù¥ÏÉÅ, Í≥®Îìú Ï∂©Î∂ÑÌï¥Ïïº Í∞ÄÎä•
            if (this.level < 3) return false;
            const upgradeCost = this.getUpgradeCost('special');
            if (gameState.gold < upgradeCost) return false;
            return true;
        }
        // ÏùºÎ∞ò ÏóÖÍ∑∏Î†àÏù¥Îìú
        if (this[`${upgradeType}Level`] >= this.maxUpgradeLevel) return false;
        const upgradeCost = this.getUpgradeCost(upgradeType);
        if (gameState.gold < upgradeCost) return false;
        return true;
    }
} // ‚Üê class Tower ÎÅùÏóê Ï§ëÍ¥ÑÌò∏ Ï∂îÍ∞Ä

// Ï†ÄÏû•Îêú Îç∞Ïù¥ÌÑ∞Î°úÎ∂ÄÌÑ∞ ÌÉÄÏõå ÏÉùÏÑ±
function towerFromData(data) {
    const tower = Object.create(Tower.prototype);
    Object.assign(tower, data);
    tower.activeBuffs = new Set(data.activeBuffs);
    tower.activeCombos = new Set(data.activeCombos);
    if (!tower.buffedTowers) tower.buffedTowers = new Set();
    // Í∏∞Î≥∏Í∞í Î≥¥Ï†ï
    if (!isFinite(tower.baseDamage)) tower.baseDamage = TOWER_TYPES[tower.type]?.damage || 1;
    if (!isFinite(tower.baseRange)) tower.baseRange = TOWER_TYPES[tower.type]?.range || 1;
    if (!isFinite(tower.baseCooldown)) tower.baseCooldown = TOWER_TYPES[tower.type]?.cooldown || 60;
    if (!isFinite(tower.range)) tower.range = tower.baseRange;
    if (!isFinite(tower.damage)) tower.damage = tower.baseDamage;
    if (!isFinite(tower.maxCooldown)) tower.maxCooldown = tower.baseCooldown;
    if (!tower.color) tower.color = TOWER_TYPES[tower.type]?.color || '#888888';
    
    return tower;
}

// ÌÉÄÏõå Í¥ÄÎ†® Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
function showTowerRangePreview(x, y, range, type) {
    if (rangePreview) {
        rangePreview.remove();
    }
    
    rangePreview = document.createElement('div');
    rangePreview.className = 'tower-range-preview';
    
    // ÌÉÄÏõå Ï§ëÏã¨ÏùÑ Í∏∞Ï§ÄÏúºÎ°ú Í≥ÑÏÇ∞
    const centerX = x * TILE_SIZE + TILE_SIZE/2;
    const centerY = (y * TILE_SIZE + TILE_SIZE * 2) + TILE_SIZE;
    const diameter = range * TILE_SIZE * 2;
    
    rangePreview.style.left = `${centerX - diameter/2}px`;
    rangePreview.style.top = `${centerY - diameter/2}px`;
    rangePreview.style.width = `${diameter}px`;
    rangePreview.style.height = `${diameter}px`;
    
    // ÌÉÄÏõå Ï¢ÖÎ•òÏóê Îî∞Î•∏ ÏÉâÏÉÅ ÏÑ§Ï†ï
    const tower = TOWER_TYPES[type];
    rangePreview.style.backgroundColor = `${tower.color}20`;
    rangePreview.style.borderColor = tower.color;
    
    document.querySelector('.game-area').appendChild(rangePreview);
}

function hideTowerRangePreview() {
    if (rangePreview) {
        rangePreview.remove();
        rangePreview = null;
    }
}

function checkTowerCombos() {
    Object.entries(TOWER_COMBOS).forEach(([comboKey, combo]) => {
        // Ï°∞Ìï© Ï°∞Í±¥ÏùÑ ÎßåÏ°±ÌïòÎäîÏßÄ ÌôïÏù∏
        const hasCombo = combo.condition ? combo.condition(towers) : true;

        if (hasCombo) {
            // Ï°∞Ìï© Ìö®Í≥º Ï†ÅÏö©
            combo.effect(towers);

            // Ï°∞Ìï© Ïù¥ÌéôÌä∏ ÌëúÏãú (Ïù¥ÎØ∏ ÌëúÏãúÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ÏóêÎßå)
            if (!shownCombos.includes(comboKey)) {
                towers.forEach(tower => {
                    if (!tower.activeCombos) tower.activeCombos = new Set();
                    tower.activeCombos.add(comboKey);
                });
                showComboEffect(combo.name);
                shownCombos.push(comboKey);
            }
        } else {
            // Ï°∞Ìï©Ïù¥ Ìï¥Ï†úÎêú Í≤ΩÏö∞
            towers.forEach(tower => {
                if (tower.activeCombos && tower.activeCombos.has(comboKey)) {
                    tower.activeCombos.delete(comboKey);
                }
            });
            // Ï°∞Ìï©Ïù¥ Ìï¥Ï†úÎêòÎ©¥ shownCombosÏóêÏÑúÎèÑ Ï†úÍ±∞
            const shownIdx = shownCombos.indexOf(comboKey);
            if (shownIdx > -1) {
                shownCombos.splice(shownIdx, 1);
            }
        }
    });
}

function showLevelUpEffect(tower) {
    if (!tower || typeof tower !== 'object' || tower.x === undefined || tower.y === undefined) {
        console.error(t('showLevelUpEffectTowerOnly'), tower);
        return;
    }
    // Ïù¥ÌéôÌä∏ ÌíÄÏóêÏÑú Ïù¥ÌéôÌä∏ Í∞ÄÏ†∏Ïò§Í∏∞
    const effect = EffectPool.get('levelUp');
    if (!effect) return;

    // Ïù¥ÌéôÌä∏ Ï¥àÍ∏∞Ìôî
    effect.x = tower.x * TILE_SIZE + TILE_SIZE / 2;  // ÌÉÄÏõåÏùò Ïã§Ï†ú ÌôîÎ©¥ Ï¢åÌëúÎ°ú Î≥ÄÌôò
    effect.y = tower.y * TILE_SIZE + TILE_SIZE / 2;  // ÌÉÄÏõåÏùò Ïã§Ï†ú ÌôîÎ©¥ Ï¢åÌëúÎ°ú Î≥ÄÌôò
    effect.alpha = 1;
    effect.scale = 0.5;
    effect.rotation = 0;
    effect.active = true;
    effect.type = 'levelUp';
    effect.duration = 1000; // 1Ï¥à ÎèôÏïà ÏßÄÏÜç
    effect.startTime = Date.now();

    // Ïù¥ÌéôÌä∏ Í∑∏Î¶¨Í∏∞ Ìï®Ïàò
    effect.draw = function () {
        if (!this.active) return;

        const elapsed = Date.now() - this.startTime;
        const progress = elapsed / this.duration;

        // ÏïåÌååÍ∞í Í∞êÏÜå (1 -> 0)
        this.alpha = 1 - progress;

        // ÌÅ¨Í∏∞ Ï¶ùÍ∞Ä (0.5 -> 2)
        this.scale = 0.5 + (progress * 1.5);

        // ÌöåÏ†Ñ (0 -> 360ÎèÑ)
        this.rotation = progress * 360;

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation * Math.PI / 180);
        ctx.scale(this.scale, this.scale);
        ctx.globalAlpha = this.alpha;

        // Î†àÎ≤®ÏóÖ Ïù¥ÌéôÌä∏ Í∑∏Î¶¨Í∏∞
        ctx.beginPath();
        ctx.arc(0, 0, 20, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 215, 0, 0.5)'; // Î∞òÌà¨Î™Ö Í∏àÏÉâ
        ctx.fill();

        // Î≥Ñ Î™®Ïñë Í∑∏Î¶¨Í∏∞
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
            const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
            const x = Math.cos(angle) * 15;
            const y = Math.sin(angle) * 15;
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        ctx.closePath();
        ctx.fillStyle = 'rgba(255, 215, 0, 0.8)'; // Îçî ÏßÑÌïú Í∏àÏÉâ
        ctx.fill();

        ctx.restore();
    };

    // Ïù¥ÌéôÌä∏ ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
    effect.update = function () {
        if (!this.active) return false;

        const elapsed = Date.now() - this.startTime;
        if (elapsed >= this.duration) {
            this.active = false;
            EffectPool.release(this);
            return false;
        }
        return true;
    };
}

// ÌÉÄÏõå Ï†ïÎ≥¥ ÌëúÏãú
function showTowerInfo(tower) {
    const info = document.createElement('div');
    info.className = 'tower-info';
    info.innerHTML = `
        <div class="tower-name">${TOWER_TYPES[tower.type].name}</div>
        <div class="tower-level">Level ${tower.level}</div>
        <div class="tower-stats">
            <div>‚öîÔ∏è ${tower.damage}</div>
            <div>üéØ ${tower.range}</div>
            <div>‚ö° ${(60 / tower.maxCooldown).toFixed(1)}</div>
        </div>
    `;
    
    // ÏúÑÏπò ÏÑ§Ï†ï
    const centerX = tower.x * TILE_SIZE + TILE_SIZE/2;
    const centerY = tower.y * TILE_SIZE + TILE_SIZE/2;
    
    info.style.left = `${centerX}px`;
    info.style.top = `${centerY - 80}px`;
    info.style.transform = 'translateX(-50%)';
    
    document.getElementById('game-container').appendChild(info);
    return info;
}

// ÌÉÄÏõå Ìò∏Î≤Ñ Ï≤òÎ¶¨
// ÎßàÏö∞Ïä§Í∞Ä ÌÉÄÏõå ÏúÑÏóê ÏûàÏùÑ ÎïåÏùò ÎèôÏûë Ï≤òÎ¶¨
function handleTowerHover(tower) {
    let infoElement = null;
    
    const showInfo = () => {
        if (!infoElement) {
            infoElement = showTowerInfo(tower);
        }
    };
    
    const hideInfo = () => {
        if (infoElement) {
            infoElement.remove();
            infoElement = null;
        }
    };
    
    return { showInfo, hideInfo };
}

// ÌÉÄÏõå Ìà¥ÌåÅ Îç∞Ïù¥ÌÑ∞
const towerTooltipData = {
    BASIC: `${t('basicTower')}\n- ${t('towerTooltipBasic1')}\n- ${t('towerTooltipBasic2')}\n- ${t('towerTooltipBasic3')}`,
    ICE: `${t('iceTower')}\n- ${t('towerTooltipIce1')}\n- ${t('towerTooltipIce2')}\n- ${t('towerTooltipIce3')}`,
    POISON: `${t('poisonTower')}\n- ${t('towerTooltipPoison1')}\n- ${t('towerTooltipPoison2')}\n- ${t('towerTooltipPoison3')}`,
    LASER: `${t('laserTower')}\n- ${t('towerTooltipLaser1')}\n- ${t('towerTooltipLaser2')}`,
    SPLASH: `${t('splashTower')}\n- ${t('towerTooltipSplash1')}\n- ${t('towerTooltipSplash2')}`,
    SUPPORT: `${t('supportTower')}\n- ${t('towerTooltipSupport1')}\n- ${t('towerTooltipSupport2')}`
};

// ÌÉÄÏõå Ìà¥ÌåÅ Í¥ÄÎ†® Î≥ÄÏàò
let tooltipEl = null;

// ÌÉÄÏõå Ìà¥ÌåÅ ÌëúÏãú Ìï®Ïàò
function showTowerTooltip(e) {
    const type = this.getAttribute('data-type');
    if (!type || !towerTooltipData[type]) return;
    if (!tooltipEl) {
        tooltipEl = document.createElement('div');
        tooltipEl.className = 'tooltip';
        document.body.appendChild(tooltipEl);
    }
    tooltipEl.textContent = towerTooltipData[type];
    tooltipEl.classList.add('show');
    // ÏúÑÏπò Í≥ÑÏÇ∞
    const rect = this.getBoundingClientRect();
    const scrollY = window.scrollY || window.pageYOffset;
    tooltipEl.style.left = `${rect.left + rect.width/2 - tooltipEl.offsetWidth/2}px`;
    tooltipEl.style.top = `${rect.bottom + scrollY + 8}px`;
}

// ÌÉÄÏõå Ìà¥ÌåÅ Ïà®Í∏∞Í∏∞
// ÌÉÄÏõå Ìà¥ÌåÅÏùÑ Ï†úÍ±∞
function hideTowerTooltip() {
    if (tooltipEl) {
        tooltipEl.classList.remove('show');
        setTimeout(() => { if (tooltipEl) tooltipEl.remove(); tooltipEl = null; }, 150);
    }
}

// Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Îì±Î°ù
document.querySelectorAll('.tower-tooltip').forEach(el => {
    el.addEventListener('mouseenter', showTowerTooltip);
    el.addEventListener('focus', showTowerTooltip);
    el.addEventListener('mouseleave', hideTowerTooltip);
    el.addEventListener('blur', hideTowerTooltip);
    // Î™®Î∞îÏùº ÌÑ∞Ïπò ÎåÄÏùë
    el.addEventListener('touchstart', function(e) {
        showTowerTooltip.call(this, e);
        e.preventDefault();
    });
    el.addEventListener('touchend', hideTowerTooltip);
});

// ÌÉÄÏõå Í±¥ÏÑ§ Î©îÎâ¥ ÌëúÏãú Ìï®Ïàò
function showTowerBuildMenu(x, y, clientX, clientY) {
    if (gameState.towerCount >= gameState.maxTowers) {
        showSaveLoadNotification(t('towerLimitReached'));
        return;
    }

    // ÌÉÄÏõå ÏóÖÍ∑∏Î†àÏù¥Îìú Î™®Îã¨Ïù¥ Ïó¥Î†§ ÏûàÏúºÎ©¥ Îã´Í∏∞
    const existingUpgradeMenu = document.querySelector('.tower-upgrade-menu');
    if (existingUpgradeMenu && existingUpgradeMenu.parentNode) {
        existingUpgradeMenu.parentNode.removeChild(existingUpgradeMenu);
    }

    const towerMenu = document.getElementById('towerMenu');
    const existingMenu = document.querySelector('.tower-build-menu');
    if (existingMenu && existingMenu.parentNode) {
        existingMenu.parentNode.removeChild(existingMenu);
    }

    const menu = document.createElement('div');
    menu.className = 'tower-build-menu';

    // Ìó§Îçî Ï∂îÍ∞Ä
    const header = document.createElement('div');
    header.className = 'tower-build-header';
    header.innerHTML = `
        <h2>${t('towerInstallation')}</h2>
        <p>${t('gold')}: ${gameState.gold}</p>
    `;
    menu.appendChild(header);

    // ÌÉÄÏõå Î¶¨Ïä§Ìä∏ ÏÉùÏÑ±
    const towerList = document.createElement('div');
    towerList.className = 'tower-list';

    Object.entries(TOWER_TYPES).forEach(([type, tower]) => {
        const card = document.createElement('div');
        card.className = `tower-card ${gameState.gold < tower.cost ? 'disabled' : ''}`;

        card.innerHTML = `
            <div class="tower-card-header">
                <div class="tower-icon" tabindex="0" style="background: ${tower.color}">${type[0]}</div>
                <div class="tower-name">${t(tower.name)}</div>
                <div class="tower-cost">${tower.cost} ${t('gold')}</div>
            </div>
            <div class="tower-details">
                <div class="tower-stats">
                    <span class="tower-stat-label">${t('attackPower')}</span> ${tower.damage} /
                    <span class="tower-stat-label">${t('range')}</span> ${tower.range} /
                    <span class="tower-stat-label">${t('cooldown')}</span> ${(tower.cooldown / 60).toFixed(2)}${t('seconds')}
                </div>
                <div class="tower-description">${getSpecialDescription(type)}</div>
            </div>
        `;

        const icon = card.querySelector('.tower-icon');
        icon.addEventListener('mouseenter', () => card.classList.add('show-details'));
        icon.addEventListener('mouseleave', () => card.classList.remove('show-details'));
        icon.addEventListener('click', (e) => {
            e.stopPropagation();
            card.classList.toggle('show-details');
        });
        icon.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                card.classList.toggle('show-details');
            }
        });

        if (gameState.gold >= tower.cost) {
            card.onmouseover = () => showTowerRangePreview(x, y, tower.range, type);
            card.onmouseout = hideTowerRangePreview;

            card.onclick = () => {
                towers.push(new Tower(x, y, type));
                gameState.gold -= tower.cost;
                gameState.towerCount++;
                updateTowerLimit();
                playSound('tower_place');
                hideTowerRangePreview();
                if (menu.parentNode) {
                    menu.parentNode.removeChild(menu);
                }
                const highlight = document.querySelector('.grid-highlight');
                if (highlight) highlight.remove();
            };
        }

        towerList.appendChild(card);
    });

    menu.appendChild(towerList);
    towerMenu.appendChild(menu);
    setupMenuCloseHandler(menu);
}

// ÌÉÄÏõå ÏóÖÍ∑∏Î†àÏù¥Îìú Î©îÎâ¥ ÌëúÏãú
// ÌÉÄÏõå ÏóÖÍ∑∏Î†àÏù¥Îìú Ïãú ÌëúÏãúÎêòÎäî Î©îÎâ¥
function showTowerUpgradeMenu(tower, clientX, clientY) {
    // ÌÉÄÏõå ÏÑ§Ïπò Î™®Îã¨Ïù¥ Ïó¥Î†§ ÏûàÏúºÎ©¥ Îã´Í∏∞
    const existingBuildMenu = document.querySelector('.tower-build-menu');
    if (existingBuildMenu && existingBuildMenu.parentNode) {
        existingBuildMenu.parentNode.removeChild(existingBuildMenu);
    }

    const towerMenu = document.getElementById('towerMenu');
    const existingMenu = document.querySelector('.tower-upgrade-menu');
    if (existingMenu && existingMenu.parentNode) {
        existingMenu.parentNode.removeChild(existingMenu);
    }

    const menu = document.createElement('div');
    menu.className = 'tower-upgrade-menu';

    // ÏÉÅÎã®: ÌÉÄÏõåÎ™Ö/Î†àÎ≤®/Ïä§ÌÉØ ÏöîÏïΩ Ìïú Ï§Ñ
    const headerRow = document.createElement('div');
    headerRow.className = 'tower-upgrade-header-row';
    headerRow.innerHTML = `
        <span class="tower-upgrade-header-title">${t(TOWER_TYPES[tower.type].name)} Lv.${tower.level}</span>
        <span class="tower-upgrade-header-stats">
            <span>‚öîÔ∏è ${Math.floor(tower.damage)}</span>
            <span>üéØ ${tower.range}</span>
            <span>‚ö° ${(60 / tower.maxCooldown).toFixed(1)}</span>
        </span>
    `;
    menu.appendChild(headerRow);

    // ÌïòÎã®: ÏóÖÍ∑∏Î†àÏù¥Îìú ÏòµÏÖò 3Í∞ú + ÌåêÎß§ Î≤ÑÌäº Ìïú Ï§Ñ
    const row = document.createElement('div');
    row.className = 'tower-upgrade-row';

    // ÏóÖÍ∑∏Î†àÏù¥Îìú ÏòµÏÖòÎì§
    const upgradeTypes = ['damage', 'range', 'speed'];
    const upgradeIcons = ['‚öîÔ∏è', 'üéØ', '‚ö°'];
    const upgradeNames = [t('upgradeDamage'), t('upgradeRange'), t('upgradeSpeed')];

    upgradeTypes.forEach((type, index) => {
        const isSupport = tower.type === 'SUPPORT';
        const canUpgrade = isSupport ? (type === 'range' && tower.canUpgrade(type)) : tower.canUpgrade(type);
        let currentValue, nextValue;
        if (type === 'damage') {
            currentValue = Math.floor(tower[type]);
            nextValue = Math.floor(tower[type] * 1.2);
        } else if (type === 'range') {
            currentValue = tower[type].toFixed(1);
            nextValue = (tower[type] * 1.2).toFixed(1);
        } else if (type === 'speed') {
            currentValue = (60 / tower.maxCooldown).toFixed(1);
            nextValue = (60 / Math.max(10, tower.maxCooldown * 0.9)).toFixed(1);
        } else {
            currentValue = tower[type];
            nextValue = tower[type];
        }
        const option = document.createElement('div');
        option.className = `upgrade-option ${canUpgrade ? '' : 'disabled'}`;
        option.innerHTML = `
            <span class="upgrade-label">${upgradeNames[index]}</span>
            <span>${upgradeIcons[index]}</span>
            <span>${currentValue}</span>
            <span class="upgrade-arrow">‚Üí</span>
            <span>${nextValue}</span>
            <span class="upgrade-cost">üí∞${tower.getUpgradeCost(type)}</span>
        `;
        if (canUpgrade) {
            option.addEventListener('click', () => {
                tower.upgrade(type);
                showUpgradeEffect(tower.x, tower.y);
                updateInfoBar();
                menu.remove();
            });
        }
        row.appendChild(option);
    });

    // ÌåêÎß§ Î≤ÑÌäº
    const sellButton = document.createElement('button');
    sellButton.className = 'sell-button';
    sellButton.innerHTML = `üíé ${t('sell')} +${tower.getSellValue()}`;
    sellButton.addEventListener('click', () => {
        gameState.gold += tower.getSellValue();
        const index = towers.indexOf(tower);
        if (index > -1) {
            towers.splice(index, 1);
            gameState.towerCount--;
            updateTowerLimit();
        }
        updateInfoBar();
        menu.remove();
    });
    row.appendChild(sellButton);

    menu.appendChild(row);
    towerMenu.appendChild(menu);
    setupMenuCloseHandler(menu);
}

// ÌäπÏàò Îä•Î†• ÏÑ§Î™Ö Î∞òÌôò
// ÌÉÄÏõå ÌÉÄÏûÖÏóê Îî∞Î•∏ ÌäπÏàò Îä•Î†• ÏÑ§Î™ÖÏùÑ Î∞òÌôò
function getSpecialDescription(type) {
    switch (type) {
        case 'ICE':
            return t('specialDescIce');
        case 'POISON':
            return t('specialDescPoison');
        case 'SUPPORT':
            return t('specialDescSupport');
        case 'BASIC':
            return t('specialDescBasic');
        case 'SNIPER':
            return t('specialDescSniper');
        case 'SPLASH':
            return t('specialDescSplash');
        case 'LASER':
            return t('specialDescLaser');
        default:
            return t('specialDescNone');
    }
}

// TOWER_TYPESÎ•º Ï†ÑÏó≠ Î≥ÄÏàòÎ°ú ÎÖ∏Ï∂ú
window.TOWER_TYPES = TOWER_TYPES;

// Ï†ÑÏó≠ Í∞ùÏ≤¥Ïóê ÎÖ∏Ï∂ú
window.Tower = Tower;
window.towerFromData = towerFromData;
window.showTowerRangePreview = showTowerRangePreview;
window.hideTowerRangePreview = hideTowerRangePreview;
window.checkTowerCombos = checkTowerCombos;
window.showLevelUpEffect = showLevelUpEffect;
window.showTowerInfo = showTowerInfo;
window.handleTowerHover = handleTowerHover;
window.towerTooltipData = towerTooltipData;
window.showTowerTooltip = showTowerTooltip;
window.hideTowerTooltip = hideTowerTooltip;
window.showTowerBuildMenu = showTowerBuildMenu;
window.showTowerUpgradeMenu = showTowerUpgradeMenu;
window.getSpecialDescription = getSpecialDescription; 